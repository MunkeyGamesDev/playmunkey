<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0" />
<title>MunkeysPlace</title>
<style>
  :root{--bg:#0b0f18;--panel:#0f1626;--line:rgba(255,255,255,.10);--txt:#eaf0ff;--muted:rgba(234,240,255,.68);--good:#44ff88;--bad:#ff4466}
  html,body{height:100%;margin:0;background:radial-gradient(1200px 800px at 20% 10%, #121f3a 0%, var(--bg) 55%, #070a11 100%);color:var(--txt);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial;overflow:hidden}
  #wrap{height:100%;display:grid;grid-template-columns:360px 1fr}
  @media (max-width: 980px){#wrap{grid-template-columns:1fr;grid-template-rows:auto 1fr}#left{border-right:none;border-bottom:1px solid var(--line);max-height:46vh}}
  #left{background:linear-gradient(180deg, rgba(255,255,255,.045), rgba(255,255,255,.018));border-right:1px solid var(--line);padding:18px;box-sizing:border-box;overflow:auto;min-width:320px}

  #title{
    font-weight:950;letter-spacing:.5px;font-size:26px;display:flex;align-items:center;gap:10px;flex-wrap:wrap;
    background: linear-gradient(90deg,
      #ff2d55 0%,
      #ffcc00 12%,
      #34c759 24%,
      #00c7ff 36%,
      #5856d6 48%,
      #ff2d55 60%,
      #ffcc00 72%,
      #34c759 84%,
      #00c7ff 96%,
      #5856d6 108%
    );
    -webkit-background-clip:text;
    background-clip:text;
    color:transparent;
    background-size: 400% 100%;
    animation: titleShift 3.5s linear infinite;
    position:relative;
    text-shadow: 0 0 22px rgba(0,199,255,.12);
  }
  #title::after{
    content:"";
    position:absolute;
    left:-10px; right:-10px; top:-8px; bottom:-8px;
    border-radius:14px;
    background: radial-gradient(400px 120px at 20% 40%, rgba(255,45,85,.18), transparent 60%),
                radial-gradient(420px 140px at 55% 30%, rgba(255,204,0,.16), transparent 62%),
                radial-gradient(420px 160px at 80% 55%, rgba(52,199,89,.14), transparent 60%),
                radial-gradient(520px 180px at 50% 70%, rgba(88,86,214,.12), transparent 65%);
    filter: blur(10px);
    opacity:.85;
    z-index:-1;
    animation: titleGlow 2.8s ease-in-out infinite;
    pointer-events:none;
  }
  @keyframes titleShift{
    0%{background-position:0% 50%}
    100%{background-position:100% 50%}
  }
  @keyframes titleGlow{
    0%,100%{transform:translateY(0px) scale(1); opacity:.75}
    50%{transform:translateY(-2px) scale(1.02); opacity:1}
  }

  .muted{color:var(--muted);font-size:12px;line-height:1.45}
  .card{margin-top:14px;background:rgba(15,22,38,.72);border:1px solid var(--line);border-radius:16px;padding:14px}
  .row{display:flex;align-items:center;justify-content:space-between;gap:12px}
  .row > *{min-width:0}
  .btn{user-select:none;cursor:pointer;background:linear-gradient(180deg, rgba(255,255,255,.12), rgba(255,255,255,.03));border:1px solid var(--line);color:var(--txt);padding:10px 12px;border-radius:12px;font-weight:850}
  .btn:hover{filter:brightness(1.12)}
  .btn:active{transform:translateY(1px)}
  .btn.small{padding:8px 10px;border-radius:10px;font-size:12px}
  #status{font-size:13px;font-weight:900}
  #status.ok{color:var(--good)}
  #status.bad{color:var(--bad)}
  #cooldown{font-size:13px;font-weight:950}
  #cooldown.ok{color:var(--good)}
  #cooldown.bad{color:var(--bad)}
  #boardBox{position:relative;height:100%}
  canvas#board{display:block;width:100%;height:100%}
  #hud{position:absolute;left:14px;top:14px;display:flex;gap:10px;flex-wrap:wrap;pointer-events:none}
  .pill{backdrop-filter: blur(10px);background:rgba(10,14,26,.58);border:1px solid var(--line);border-radius:999px;padding:8px 10px;font-size:12px;color:var(--muted)}
  #pickerWrap{display:flex;gap:12px;align-items:stretch;margin-top:10px;flex-wrap:wrap}
  #wheelWrap{display:flex;flex-direction:column;gap:10px;align-items:flex-start}
  #wheel{width:220px;height:220px;border-radius:50%;border:1px solid var(--line);position:relative;cursor:crosshair;overflow:hidden;background:rgba(0,0,0,.18)}
  #wheelCanvas{width:100%;height:100%;display:block}
  #wheelDot{position:absolute;width:12px;height:12px;border-radius:50%;border:2px solid #fff;box-shadow:0 0 0 2px rgba(0,0,0,.35);transform:translate(-50%,-50%);left:50%;top:50%;pointer-events:none}
  #previewBox{display:flex;gap:12px;align-items:center}
  #preview{width:64px;height:64px;border-radius:14px;border:1px solid var(--line);background:#ff0044;box-shadow:0 10px 30px rgba(0,0,0,.35)}
  #controls{flex:1;min-width:180px;display:flex;flex-direction:column;gap:10px}
  input[type="range"]{width:100%}
  #mini{display:grid;grid-template-columns:1fr 1fr;gap:10px}
  .stat{background:rgba(255,255,255,.035);border:1px solid var(--line);border-radius:14px;padding:10px;min-width:0}
  .stat b{display:block;font-size:16px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
  #hintKeys{margin-top:10px}
  .k{display:inline-flex;align-items:center;justify-content:center;min-width:28px;padding:4px 8px;border-radius:10px;border:1px solid var(--line);background:rgba(255,255,255,.05);font-weight:900;color:var(--txt);font-size:12px}
  #errBox{margin-top:10px;padding:10px 12px;border-radius:14px;border:1px solid rgba(255,68,102,.35);background:rgba(255,68,102,.10);display:none}
  #errBox b{color:var(--bad)}
  #errText{margin-top:6px;color:rgba(234,240,255,.9);white-space:pre-wrap}
</style>
</head>
<body>
<div id="wrap">
  <div id="left">
    <div id="title">MunkeysPlace</div>
    <div class="muted" style="margin-top:8px">Place <b>one</b> pixel per hour. Everyone sees updates live.</div>

    <div class="card">
      <div class="row">
        <div>
          <div class="muted">Connection</div>
          <div id="status" class="bad">Not connected</div>
        </div>
        <button id="reconnect" class="btn small">Reconnect</button>
      </div>
      <div style="height:10px"></div>
      <div class="row">
        <div>
          <div class="muted">Cooldown</div>
          <div id="cooldown" class="ok">Ready</div>
        </div>
        <button id="center" class="btn small">Center</button>
      </div>
      <div id="errBox"><b>Place failed</b><div id="errText"></div></div>
    </div>

    <div class="card">
      <div class="row" style="align-items:flex-start">
        <div>
          <div class="muted">Pick a color</div>
          <div style="font-weight:950;font-size:14px;margin-top:4px">Wheel + Brightness</div>
        </div>
        <div id="previewBox"><div id="preview"></div></div>
      </div>

      <div id="pickerWrap">
        <div id="wheelWrap">
          <div id="wheel">
            <canvas id="wheelCanvas" width="220" height="220"></canvas>
            <div id="wheelDot"></div>
          </div>
          <div class="muted">Click/drag in the wheel to pick.</div>
        </div>

        <div id="controls">
          <div>
            <div class="muted">Brightness</div>
            <input id="bright" type="range" min="0" max="100" value="100" />
          </div>

          <div class="muted">Board</div>
          <div id="mini">
            <div class="stat"><div class="muted">Zoom</div><b id="zoomLbl">1.0×</b></div>
          </div>

          <div id="hintKeys" class="muted">Drag to pan • Mousewheel to zoom • Click to place • <span class="k">C</span> center</div>
        </div>
      </div>
    </div>
  </div>

  <div id="boardBox">
    <canvas id="board"></canvas>
    <div id="hud">
      <div class="pill" id="hoverPill">x: — y: —</div>
      <div class="pill">MunkeysPlace • live</div>
    </div>
  </div>
</div>

<script type="module">
import { createClient } from "https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/+esm";

const BOARD_W = 200;
const BOARD_H = 200;
const PIXEL_SIZE = 6;

const SUPABASE_URL = "https://gwiveqgfbslonwmvtluv.supabase.co";
const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imd3aXZlcWdmYnNsb253bXZ0bHV2Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzA4NTIxNTQsImV4cCI6MjA4NjQyODE1NH0.QEJDJXCURL-HxsFyIJmA6wLjLvnrIFLHnS_4ezL-quE";

const FUNCTION_NAME = "index";

const $ = (id)=>document.getElementById(id);

const canvas = document.getElementById("board");
const ctx = canvas.getContext("2d", { alpha:false });

const statusEl = $("status");
const cooldownEl = $("cooldown");
const hoverPill = $("hoverPill");
const zoomLbl = $("zoomLbl");
const errBox = $("errBox");
const errText = $("errText");

const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY, { realtime: { params: { eventsPerSecond: 60 } } });

const pixels = new Map();

let dpr = Math.max(1, window.devicePixelRatio || 1);
let zoom = 1;
let offsetX = 0;
let offsetY = 0;
let isPanning = false;
let panStart = {x:0,y:0,ox:0,oy:0};

let cooldownUntil = 0;
let cooldownTimer = null;

function showErr(msg){
  errText.textContent = msg || "";
  errBox.style.display = msg ? "block" : "none";
}
function setStatus(ok, msg){
  statusEl.textContent = msg;
  statusEl.className = ok ? "ok" : "bad";
}
function setCooldown(remainingSec){
  if (!remainingSec || remainingSec <= 0){
    cooldownUntil = 0;
    cooldownEl.textContent = "Ready";
    cooldownEl.className = "ok";
    return;
  }
  cooldownUntil = Date.now() + remainingSec*1000;
  cooldownEl.className = "bad";
  tickCooldown();
  if (cooldownTimer) clearInterval(cooldownTimer);
  cooldownTimer = setInterval(tickCooldown, 250);
}
function tickCooldown(){
  const left = Math.max(0, cooldownUntil - Date.now());
  if (left <= 0){
    if (cooldownTimer) clearInterval(cooldownTimer);
    cooldownTimer = null;
    setCooldown(0);
    return;
  }
  const s = Math.ceil(left/1000);
  const m = Math.floor(s/60);
  const r = s%60;
  cooldownEl.textContent = `Wait ${m}:${String(r).padStart(2,"0")}`;
}

function resize(){
  dpr = Math.max(1, window.devicePixelRatio || 1);
  canvas.width = Math.floor(canvas.clientWidth * dpr);
  canvas.height = Math.floor(canvas.clientHeight * dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
  draw();
}
window.addEventListener("resize", resize);

function updateZoomLbl(){ zoomLbl.textContent = `${zoom.toFixed(2)}×`; }
function centerView(){
  zoom = 1;
  offsetX = (canvas.clientWidth/2) - (BOARD_W*PIXEL_SIZE*zoom)/2;
  offsetY = (canvas.clientHeight/2) - (BOARD_H*PIXEL_SIZE*zoom)/2;
  updateZoomLbl();
  draw();
}
function screenToBoard(sx,sy){
  const x = Math.floor((sx - offsetX) / (PIXEL_SIZE*zoom));
  const y = Math.floor((sy - offsetY) / (PIXEL_SIZE*zoom));
  return { x, y };
}
function draw(){
  ctx.fillStyle = "#070a11";
  ctx.fillRect(0,0,canvas.clientWidth,canvas.clientHeight);

  const ps = PIXEL_SIZE*zoom;

  const x0 = Math.max(0, Math.floor((0 - offsetX)/ps)-1);
  const y0 = Math.max(0, Math.floor((0 - offsetY)/ps)-1);
  const x1 = Math.min(BOARD_W-1, Math.floor((canvas.clientWidth - offsetX)/ps)+1);
  const y1 = Math.min(BOARD_H-1, Math.floor((canvas.clientHeight - offsetY)/ps)+1);

  ctx.strokeStyle = "rgba(255,255,255,.045)";
  ctx.lineWidth = 1;

  for (let x=x0; x<=x1; x++){
    const sx = offsetX + x*ps;
    ctx.beginPath();
    ctx.moveTo(sx, offsetY + y0*ps);
    ctx.lineTo(sx, offsetY + (y1+1)*ps);
    ctx.stroke();
  }
  for (let y=y0; y<=y1; y++){
    const sy = offsetY + y*ps;
    ctx.beginPath();
    ctx.moveTo(offsetX + x0*ps, sy);
    ctx.lineTo(offsetX + (x1+1)*ps, sy);
    ctx.stroke();
  }

  for (let y=y0; y<=y1; y++){
    for (let x=x0; x<=x1; x++){
      const k = x + "," + y;
      const c = pixels.get(k);
      if (!c) continue;
      ctx.fillStyle = c;
      ctx.fillRect(offsetX + x*ps, offsetY + y*ps, ps, ps);
    }
  }

  ctx.strokeStyle = "rgba(255,255,255,.16)";
  ctx.lineWidth = 2;
  ctx.strokeRect(offsetX, offsetY, BOARD_W*ps, BOARD_H*ps);
}

const wheel = $("wheel");
const wheelCanvas = $("wheelCanvas");
const wctx = wheelCanvas.getContext("2d");
const wheelDot = $("wheelDot");
const bright = $("bright");
const preview = $("preview");

let pickX = wheelCanvas.width/2;
let pickY = wheelCanvas.height/2;
let pickedRGB = {r:255,g:0,b:68};

function clamp(v,a,b){return Math.max(a,Math.min(b,v));}
function rgbToHex(r,g,b){
  const h=(n)=>n.toString(16).padStart(2,"0");
  return "#" + h(r) + h(g) + h(b);
}
function applyBrightness(rgb){
  const f = Number(bright.value)/100;
  const r = Math.round(rgb.r * f);
  const g = Math.round(rgb.g * f);
  const b = Math.round(rgb.b * f);
  return {r,g,b};
}
function drawWheel(){
  const W = wheelCanvas.width;
  const H = wheelCanvas.height;
  const cx = W/2;
  const cy = H/2;
  const rad = Math.min(W,H)/2 - 1;

  const img = wctx.createImageData(W,H);
  const data = img.data;

  for (let y=0; y<H; y++){
    for (let x=0; x<W; x++){
      const dx = x - cx;
      const dy = y - cy;
      const d = Math.sqrt(dx*dx + dy*dy);
      const i = (y*W + x)*4;

      if (d > rad){ data[i+3]=0; continue; }

      let ang = Math.atan2(dy, dx);
      if (ang < 0) ang += Math.PI*2;

      const hue = ang / (Math.PI*2);
      const sat = clamp(d / rad, 0, 1);

      const c = 1;
      const hp = hue * 6;
      const xcol = c * (1 - Math.abs((hp % 2) - 1));
      let r1=0,g1=0,b1=0;

      if (0<=hp && hp<1){r1=c;g1=xcol;b1=0}
      else if (1<=hp && hp<2){r1=xcol;g1=c;b1=0}
      else if (2<=hp && hp<3){r1=0;g1=c;b1=xcol}
      else if (3<=hp && hp<4){r1=0;g1=xcol;b1=c}
      else if (4<=hp && hp<5){r1=xcol;g1=0;b1=c}
      else {r1=c;g1=0;b1=xcol}

      const r = Math.round((r1*sat + (1-sat)) * 255);
      const g = Math.round((g1*sat + (1-sat)) * 255);
      const b = Math.round((b1*sat + (1-sat)) * 255);

      data[i]=r; data[i+1]=g; data[i+2]=b; data[i+3]=255;
    }
  }
  wctx.putImageData(img,0,0);
}
drawWheel();

function updatePreview(){
  const adj = applyBrightness(pickedRGB);
  const hex = rgbToHex(adj.r, adj.g, adj.b);
  preview.style.background = hex;
  return hex;
}
function setDot(x,y){
  const W = wheelCanvas.width;
  const H = wheelCanvas.height;
  const cx = W/2;
  const cy = H/2;
  const rad = Math.min(W,H)/2 - 1;

  const dx = x - cx;
  const dy = y - cy;
  const d = Math.sqrt(dx*dx + dy*dy);
  const scale = d > rad ? (rad / d) : 1;

  pickX = Math.round(cx + dx*scale);
  pickY = Math.round(cy + dy*scale);

  wheelDot.style.left = (pickX / W * 100) + "%";
  wheelDot.style.top  = (pickY / H * 100) + "%";

  const px = wctx.getImageData(pickX, pickY, 1, 1).data;
  pickedRGB = { r:px[0], g:px[1], b:px[2] };
  updatePreview();
}
function wheelPointFromClient(clientX, clientY){
  const r = wheel.getBoundingClientRect();
  const x = (clientX - r.left) * (wheelCanvas.width / r.width);
  const y = (clientY - r.top) * (wheelCanvas.height / r.height);
  return {x, y};
}
wheel.addEventListener("pointerdown", (e)=>{
  wheel.setPointerCapture(e.pointerId);
  const p = wheelPointFromClient(e.clientX, e.clientY);
  setDot(p.x, p.y);
  const move = (ev)=>{ const p2 = wheelPointFromClient(ev.clientX, ev.clientY); setDot(p2.x, p2.y); };
  const up = ()=>{
    wheel.removeEventListener("pointermove", move);
    wheel.removeEventListener("pointerup", up);
    wheel.removeEventListener("pointercancel", up);
  };
  wheel.addEventListener("pointermove", move);
  wheel.addEventListener("pointerup", up);
  wheel.addEventListener("pointercancel", up);
});
bright.addEventListener("input", updatePreview);
setDot(wheelCanvas.width/2, wheelCanvas.height*0.18);

canvas.addEventListener("pointerdown", (e)=>{
  if (e.button !== 0) return;
  isPanning = true;
  canvas.setPointerCapture(e.pointerId);
  panStart = { x:e.clientX, y:e.clientY, ox:offsetX, oy:offsetY };
});
canvas.addEventListener("pointermove", (e)=>{
  const rect = canvas.getBoundingClientRect();
  const sx = e.clientX - rect.left;
  const sy = e.clientY - rect.top;
  const b = screenToBoard(sx, sy);
  hoverPill.textContent = `x: ${b.x} y: ${b.y}`;

  if (!isPanning) return;
  const dx = e.clientX - panStart.x;
  const dy = e.clientY - panStart.y;
  offsetX = panStart.ox + dx;
  offsetY = panStart.oy + dy;
  draw();
});
canvas.addEventListener("pointerup", async (e)=>{
  if (!isPanning) return;
  isPanning = false;

  const moved = Math.hypot(e.clientX - panStart.x, e.clientY - panStart.y);
  if (moved > 3) return;

  const rect = canvas.getBoundingClientRect();
  const sx = e.clientX - rect.left;
  const sy = e.clientY - rect.top;
  const {x,y} = screenToBoard(sx, sy);

  if (x<0 || y<0 || x>=BOARD_W || y>=BOARD_H) return;
  if (cooldownUntil && Date.now() < cooldownUntil) return;

  showErr("");
  const color = updatePreview();
  await placePixel(x,y,color);
});
canvas.addEventListener("wheel", (e)=>{
  e.preventDefault();
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;

  const before = screenToBoard(mx,my);
  const delta = Math.sign(e.deltaY);
  const factor = delta > 0 ? 0.9 : 1.1;
  const newZoom = Math.min(12, Math.max(0.2, zoom * factor));
  if (newZoom === zoom) return;

  zoom = newZoom;
  updateZoomLbl();

  const ps = PIXEL_SIZE*zoom;
  offsetX = mx - before.x * ps;
  offsetY = my - before.y * ps;
  draw();
},{passive:false});

window.addEventListener("keydown", (e)=>{ if (e.key.toLowerCase() === "c") centerView(); });
$("center").addEventListener("click", centerView);

async function loadBoard(){
  const { data, error } = await supabase.from("pixels").select("x,y,color").limit(120000);
  if (error) throw error;
  pixels.clear();
  for (const p of data) pixels.set(p.x + "," + p.y, p.color);
  draw();
}

let channel = null;
function subscribeRealtime(){
  if (channel) supabase.removeChannel(channel);
  channel = supabase
    .channel("munkeysplace:pixels")
    .on("postgres_changes",{ event:"*", schema:"public", table:"pixels" }, (payload)=>{
      const row = payload.new;
      if (!row) return;
      pixels.set(row.x + "," + row.y, row.color);
      draw();
    })
    .subscribe((st)=>{
      if (st === "SUBSCRIBED"){
        setStatus(true, "Connected");
      }
    });
}

$("reconnect").addEventListener("click", async ()=>{
  try{
    setStatus(false, "Reconnecting...");
    showErr("");
    await init();
  }catch(e){
    setStatus(false, "Reconnect failed");
    showErr(String(e?.message || e || "Reconnect failed"));
  }
});

async function placePixel(x,y,color){
  try{
    const { data, error } = await supabase.functions.invoke(FUNCTION_NAME, {
      body: { x, y, color, boardW: BOARD_W, boardH: BOARD_H }
    });

    if (error){
      const msg = (error?.context?.body && typeof error.context.body === "string")
        ? error.context.body
        : (error?.message || "Function invoke error");
      showErr(msg);
      return;
    }

    if (data?.error === "COOLDOWN"){
      const rs = data?.remainingSeconds || 3600;
      setCooldown(rs);
      showErr(`Cooldown: ${rs} seconds remaining.`);
      return;
    }

    if (data && data.ok !== true){
      const msg = typeof data === "string" ? data : JSON.stringify(data);
      showErr(msg);
      return;
    }

    pixels.set(x + "," + y, color);
    draw();
    setCooldown(3600);
    showErr("");
  }catch(e){
    const msg = String(e?.message || e || "Unknown error");
    showErr(msg);
  }
}

async function init(){
  setStatus(false, "Connecting...");
  showErr("");

  try{
    const { data: { session } } = await supabase.auth.getSession();
    if (!session){
      await supabase.auth.signInAnonymously();
    }
  }catch(e){}

  await loadBoard();
  subscribeRealtime();
  setStatus(true, "Connected");
}

resize();
centerView();
updateZoomLbl();
updatePreview();

init().catch((e)=>{
  setStatus(false, "Connection failed");
  const msg = String(e?.message || e || "Init failed");
  showErr(msg);
});
</script>
</body>
</html>
