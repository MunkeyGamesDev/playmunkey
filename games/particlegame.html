<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Particle Game</title>
<style>
body{margin:0;background:#0a0a0a;color:#fff;font-family:'Segoe UI',sans-serif;display:flex;flex-direction:column;align-items:center;height:100vh;overflow:hidden}
#header{width:100%;background:linear-gradient(135deg,#1a1a2e,#16213e);padding:10px;box-shadow:0 2px 10px rgba(0,0,0,.5)}
#toolbar{display:grid;grid-template-columns:repeat(auto-fit,minmax(70px,1fr));gap:4px;padding:10px;background:#1a1a1a;border-radius:8px;max-height:180px;overflow-y:auto;scrollbar-width:thin}
.element-btn{width:70px;height:40px;border:none;cursor:pointer;border-radius:6px;font-size:10px;color:#000;font-weight:700;text-shadow:1px 1px 1px rgba(255,255,255,.7);transition:all .2s ease;box-shadow:0 2px 4px rgba(0,0,0,.3)}
.element-btn:hover{transform:translateY(-2px);box-shadow:0 4px 8px rgba(0,0,0,.4)}
.element-btn.active{border:2px solid #00ff00;box-shadow:0 0 15px rgba(0,255,0,.5)}
.category-header{grid-column:1/-1;background:#333;color:#fff;text-align:center;padding:6px;margin:4px 0;border-radius:4px;font-weight:700;font-size:11px}
#controls{display:flex;align-items:center;justify-content:center;flex-wrap:wrap;gap:20px;padding:15px;background:#1a1a1a;border-radius:8px;margin:10px}
.control-group{display:flex;align-items:center;gap:10px}
.control-btn{padding:10px 20px;background:#333;color:#fff;border:none;border-radius:6px;cursor:pointer;transition:all .2s ease;font-size:14px}
.control-btn:hover{background:#555}
.control-btn.active{background:#00aa00}
canvas{border:2px solid #444;background:#000;cursor:crosshair;border-radius:8px;box-shadow:0 4px 20px rgba(0,0,0,.5)}
#info-panel{position:absolute;top:15px;right:15px;background:rgba(0,0,0,.85);padding:15px;border-radius:8px;min-width:200px;backdrop-filter:blur(10px);border:1px solid #333}
#fps{color:#0f0;font-size:16px;font-weight:700;margin-bottom:8px}
#particles{color:#aaa;font-size:12px;margin-bottom:10px}
#current-tool{color:#fff;font-size:14px;font-weight:700;margin-bottom:8px}
#tool-info{color:#ccc;font-size:11px;line-height:1.4}
.slider-container{display:flex;align-items:center;gap:10px}
.slider{width:100px}
label{font-size:14px;font-weight:500}
#brushVal,#heatVal{min-width:30px;text-align:center;font-size:13px}
</style>
</head>
<body>
<div id="header">
  <div id="toolbar"></div>
</div>

<div id="controls">
  <div class="control-group">
    <label>Brush Size:</label>
    <div class="slider-container">
      <input type="range" id="brush" class="slider" min="1" max="15" value="5">
      <span id="brushVal">5</span>
    </div>
  </div>

  <div class="control-group">
    <label>Temperature:</label>
    <div class="slider-container">
      <input type="range" id="heat" class="slider" min="-50" max="200" value="25">
      <span id="heatVal">25째C</span>
    </div>
  </div>

  <button class="control-btn" id="resetBtn">Reset</button>
  <button class="control-btn" id="pauseBtn">Pause</button>
  <button class="control-btn" id="speedBtn">x1 Speed</button>
  <button class="control-btn" id="gravityBtn">Normal Gravity</button>
  <button class="control-btn" id="rainBtn">Make Rain</button>
</div>

<div id="info-panel">
  <div id="fps">FPS: --</div>
  <div id="particles">Particles: 0</div>
  <div id="current-tool">Current: Sand</div>
  <div id="tool-info">Sand: Basic granular material, absorbs water to become mud</div>
</div>

<canvas id="game" width="800" height="500"></canvas>

<script>
const canvas=document.getElementById("game");
const ctx=canvas.getContext("2d",{alpha:false});
const gridSize=2;
const cols=Math.floor(canvas.width/gridSize);
const rows=Math.floor(canvas.height/gridSize);
const size=cols*rows;

const EMPTY=0,SAND=1,WATER=2,FIRE=3,WALL=4,LAVA=5,STONE=6,OIL=7,SMOKE=8;
const PLANT=10,ACID=11,ICE=12,METAL=13,ELEC=14,GUNPOWDER=15,WOOD=16,GLASS=17,SALT=19;
const VIRUS=21,CRYSTAL=22,MAGMA=23,CONCRETE=25,SNOW=27,MUD=28,HONEY=29;
const LIQUID_N=32,CLONE=34,SEED=35,DIAMOND=36;
const LIFE=48,FUNGUS=56,CORAL=57,ASH=58,RADIATION=59,WIRE=61,BATTERY=62,CLOUD=63;

const names=[
  "Empty","Sand","Water","Fire","Wall","Lava","Stone","Oil","Smoke","",
  "Plant","Acid","Ice","Metal","Electricity","Gunpowder","Wood","Glass","","Salt",
  "","Virus","Crystal","Magma","","Concrete","","Snow","Mud","Honey",
  "","","Liquid N","","Clone","Seed","Diamond","","","",
  "","","","","","","","",
  "Life","","","","","","","",
  "Fungus","Coral","Ash","Radiation","","Wire","Battery","Cloud"
];

let colors={
  1:"#DAA520",2:"#4169E1",3:"#FF4500",4:"#696969",5:"#FF6347",6:"#2F4F4F",7:"#8B4513",8:"#D3D3D3",
  10:"#228B22",11:"#00FF00",12:"#00CED1",13:"#C0C0C0",14:"#9370DB",15:"#2F2F2F",16:"#7A4A1E",17:"#87CEEB",19:"#FFFFFF",
  21:"#800080",22:"#FF1493",23:"#DC143C",25:"#808080",27:"#FFFAFA",28:"#8B4513",29:"#FFD700",
  32:"#87CEFA",34:"#40E0D0",35:"#228B22",36:"#B9F2FF",
  48:"#00FF80",56:"#654321",57:"#FF7F50",58:"#6E6E6E",59:"#00FF00",61:"#FFD700",62:"#FFA500",63:"#A9A9A9"
};

const grid=new Uint16Array(size);
const temp=new Float32Array(size);
const temp2=new Float32Array(size);
const velX=new Float32Array(size);
const velY=new Float32Array(size);
const updated=new Uint8Array(size);
const batteryCharge=new Uint16Array(size);
const cloudMoisture=new Uint16Array(size);
const waterContent=new Uint16Array(size);

let tool=SAND;
let drawing=false;
let paused=false;
let brush=5;
let speed=1;
let gravity=1;
let ambientHeat=25;
let particleCount=0;
let globalRain=false;
let wind=0;
let tick=0;
let suppressCloudRain=false;

const toolbar=document.getElementById("toolbar");
const fpsDisplay=document.getElementById("fps");
const particleDisplay=document.getElementById("particles");
const currentToolDisplay=document.getElementById("current-tool");
const toolInfoDisplay=document.getElementById("tool-info");
const brushSlider=document.getElementById("brush");
const brushVal=document.getElementById("brushVal");
const heatSlider=document.getElementById("heat");
const heatVal=document.getElementById("heatVal");

const categories={
  "Basic Elements":[SAND,WATER,FIRE,WALL,STONE,ASH],
  "Liquids":[LAVA,MAGMA,OIL,ACID,HONEY,MUD],
  "Gases":[SMOKE,CLOUD],
  "Organic":[PLANT,WOOD,SEED,VIRUS,LIFE,FUNGUS,CORAL],
  "Metals":[METAL,CONCRETE,WIRE,BATTERY],
  "Crystals":[ICE,SNOW,GLASS,CRYSTAL,DIAMOND,SALT],
  "Energy":[ELEC,RADIATION],
  "Explosives":[GUNPOWDER,LIQUID_N],
  "Special":[CLONE]
};

function getParticleInfo(type){
  const info={
    [SAND]:"Sand: Falls and piles up. Only turns into mud when it touches water.",
    [WATER]:"Water: Flows and settles. Freezes below 0째C. Turns into smoke when boiled or flashed by heat.",
    [FIRE]:"Fire: Burns flammables, heats neighbors, makes smoke/ash. Extinguished by water.",
    [WALL]:"Wall: Indestructible barrier.",
    [LAVA]:"Lava: Hot liquid rock. Heats/burns nearby. Cools into stone; turns water into smoke/stone.",
    [MAGMA]:"Magma: Hotter than lava. Melts stone/metal more aggressively. Cools into stone.",
    [STONE]:"Stone: Solid. Can melt into lava at very high temperature.",
    [OIL]:"Oil: Flammable liquid. Floats on water and ignites easily.",
    [SMOKE]:"Smoke: Rises and dissipates over time.",
    [CLOUD]:"Cloud: Drifts slowly and rises. Builds moisture from nearby water and can rain (not while you're placing clouds).",
    [PLANT]:"Plant: Grows near water (slow). Burns easily. Can be infected by virus.",
    [WOOD]:"Wood: Solid organic. Burns into fire/ash; can be infected.",
    [SEED]:"Seed: Sprouts into wood/plant if touching wet soil/water (slow).",
    [MUD]:"Mud: Wet sand. Flows slowly and stays mud (does not dry back). Helps seeds grow.",
    [HONEY]:"Honey: Very viscous liquid. Burns slowly; thickly flows.",
    [ACID]:"Acid: Corrosive liquid. Dissolves most materials (not wall/diamond). Diluted by lots of water.",
    [ICE]:"Ice: Solid frozen water. Melts above 0째C.",
    [SNOW]:"Snow: Light frozen powder. Melts slowly.",
    [GLASS]:"Glass: Brittle solid. Made by melting sand; can crack from extreme heat/cold.",
    [SALT]:"Salt: Powder that falls. Dissolves in water.",
    [CRYSTAL]:"Crystal: Grows from water slowly, conducts electricity. Can be etched by acid.",
    [DIAMOND]:"Diamond: Extremely durable. Resists heat/acid.",
    [METAL]:"Metal: Solid conductor. Melts when very hot.",
    [WIRE]:"Wire: Durable conductor that carries electricity without being destroyed.",
    [BATTERY]:"Battery: Stores electricity and discharges bursts into nearby conductors/empty space.",
    [ELEC]:"Electricity: Spreads through water/metal/crystal/wire. Ignites flammables. Short-lived sparks.",
    [GUNPOWDER]:"Gunpowder: Falls like powder. Explodes if touched by fire/electricity.",
    [LIQUID_N]:"Liquid Nitrogen: Super-cold liquid. Freezes nearby water; snuffs fire; chills area.",
    [VIRUS]:"Virus: Spreads through organics and life; slowly dies out.",
    [LIFE]:"Life: Spawns seeds/plants occasionally in empty nearby cells (slow).",
    [FUNGUS]:"Fungus: Spreads through organics; tends to climb upward (slow).",
    [CORAL]:"Coral: Grows only next to water and expands slowly.",
    [ASH]:"Ash: Light powder. Falls; dissolves a bit in water.",
    [RADIATION]:"Radiation: Randomly mutates nearby particles over time.",
    [CLONE]:"Clone: Mimics a nearby particle type occasionally."
  };
  return info[type]||"Unknown particle";
}

function idx(x,y){return y*cols+x;}
function inBounds(x,y){return x>=0&&x<cols&&y>=0&&y<rows;}
function setCell(i,t,h){
  grid[i]=t;
  temp[i]=h;
  velX[i]=0;
  velY[i]=0;
  batteryCharge[i]=0;
  cloudMoisture[i]=0;
  waterContent[i]=0;
  if(t===CLOUD) cloudMoisture[i]=80+((Math.random()*80)|0);
  if(t===MUD) waterContent[i]=50;
}
function clearCell(i){
  grid[i]=EMPTY;
  temp[i]=ambientHeat;
  velX[i]=0;
  velY[i]=0;
  batteryCharge[i]=0;
  cloudMoisture[i]=0;
  waterContent[i]=0;
}
function swapI(a,b){
  const ta=grid[a],tb=grid[b];
  grid[a]=tb;grid[b]=ta;
  let t=temp[a];temp[a]=temp[b];temp[b]=t;
  t=velX[a];velX[a]=velX[b];velX[b]=t;
  t=velY[a];velY[a]=velY[b];velY[b]=t;
  let u=batteryCharge[a];batteryCharge[a]=batteryCharge[b];batteryCharge[b]=u;
  u=cloudMoisture[a];cloudMoisture[a]=cloudMoisture[b];cloudMoisture[b]=u;
  u=waterContent[a];waterContent[a]=waterContent[b];waterContent[b]=u;
  updated[a]=1;updated[b]=1;
}
function moveI(a,b){
  grid[b]=grid[a];
  temp[b]=temp[a];
  velX[b]=velX[a];
  velY[b]=velY[a];
  batteryCharge[b]=batteryCharge[a];
  cloudMoisture[b]=cloudMoisture[a];
  waterContent[b]=waterContent[a];
  updated[b]=1;
  clearCell(a);
  updated[a]=1;
}

function isGas(t){return t===SMOKE||t===CLOUD;}
function isPowder(t){return t===SAND||t===ASH||t===GUNPOWDER||t===SALT||t===SNOW;}
function isLiquid(t){return t===WATER||t===OIL||t===LAVA||t===MAGMA||t===ACID||t===HONEY||t===MUD||t===LIQUID_N;}
function isSolid(t){return t===STONE||t===METAL||t===WOOD||t===PLANT||t===GLASS||t===CRYSTAL||t===DIAMOND||t===CONCRETE||t===WIRE||t===BATTERY||t===WALL||t===ICE||t===CORAL||t===FUNGUS||t===SEED||t===VIRUS||t===LIFE;}
function passGas(t){return t===SMOKE||t===CLOUD;}

function density(t){
  if(t===EMPTY) return -1000;
  if(isGas(t)) return -10;
  if(t===OIL) return 1;
  if(t===WATER) return 2;
  if(t===LIQUID_N) return 2;
  if(t===HONEY) return 3;
  if(t===ACID) return 4;
  if(t===MUD) return 5;
  if(isPowder(t)) return 6;
  if(t===LAVA) return 7;
  if(t===MAGMA) return 8;
  if(isSolid(t)) return 50;
  return 10;
}

function trySwapDensity(a,b){
  const ta=grid[a],tb=grid[b];
  if(tb===EMPTY) return false;
  if(passGas(tb)) return false;
  if(tb===WALL||tb===DIAMOND) return false;
  if(density(ta)>density(tb)){swapI(a,b);return true;}
  return false;
}

function neighbors8(x,y,arr){
  let k=0;
  for(let dy=-1;dy<=1;dy++){
    const ny=y+dy;
    if(ny<0||ny>=rows) continue;
    for(let dx=-1;dx<=1;dx++){
      if(dx===0&&dy===0) continue;
      const nx=x+dx;
      if(nx<0||nx>=cols) continue;
      arr[k++]=idx(nx,ny);
    }
  }
  return k;
}

function explode(x,y,radius,power){
  const r2=radius*radius;
  for(let dy=-radius;dy<=radius;dy++){
    const ny=y+dy;
    if(ny<0||ny>=rows) continue;
    for(let dx=-radius;dx<=radius;dx++){
      const nx=x+dx;
      if(nx<0||nx>=cols) continue;
      if(dx*dx+dy*dy>r2) continue;
      const i=idx(nx,ny);
      const t=grid[i];
      if(t===WALL||t===DIAMOND) continue;
      if(Math.random()<0.72*power){
        grid[i]=Math.random()<0.35?FIRE:EMPTY;
        temp[i]=Math.max(temp[i],900);
        const dist=Math.hypot(dx,dy);
        if(dist>0){
          velX[i]+=dx/dist*power*5.5;
          velY[i]+=dy/dist*power*5.5;
        }
        updated[i]=1;
      }
    }
  }
}

function initializeUI(){
  brushSlider.oninput=()=>{
    brush=parseInt(brushSlider.value,10);
    brushVal.innerText=brush;
  };
  heatSlider.oninput=()=>{
    ambientHeat=parseInt(heatSlider.value,10);
    heatVal.innerText=ambientHeat+"째C";
  };

  document.getElementById("resetBtn").onclick=()=>{
    grid.fill(EMPTY);
    for(let i=0;i<size;i++){
      temp[i]=25;
      velX[i]=0;velY[i]=0;
      batteryCharge[i]=0;
      cloudMoisture[i]=0;
      waterContent[i]=0;
      updated[i]=0;
    }
    globalRain=false;
    const btn=document.getElementById("rainBtn");
    btn.innerText="Make Rain";
    btn.classList.remove("active");
  };

  document.getElementById("pauseBtn").onclick=()=>{
    paused=!paused;
    document.getElementById("pauseBtn").innerHTML=paused?"Resume":"Pause";
  };

  document.getElementById("speedBtn").onclick=()=>{
    speed=speed>=4?1:speed+1;
    document.getElementById("speedBtn").innerHTML=`x${speed} Speed`;
  };

  document.getElementById("gravityBtn").onclick=()=>{
    gravity=gravity===1?0:gravity===0?-1:1;
    const text=gravity===1?"Normal":gravity===0?"Zero":"Reverse";
    document.getElementById("gravityBtn").innerHTML=text+" Gravity";
  };

  document.getElementById("rainBtn").onclick=()=>{
    globalRain=!globalRain;
    const btn=document.getElementById("rainBtn");
    btn.innerText=globalRain?"Stop Rain":"Make Rain";
    btn.classList.toggle("active",globalRain);
  };

  window.addEventListener("keydown",(e)=>{
    if(e.code==="Space"){
      e.preventDefault();
      paused=!paused;
      document.getElementById("pauseBtn").innerHTML=paused?"Resume":"Pause";
    }
    if(e.code==="KeyR"){
      e.preventDefault();
      document.getElementById("resetBtn").click();
    }
    if(e.code==="KeyE"){
      tool=EMPTY;
      currentToolDisplay.innerText="Current: Empty";
      toolInfoDisplay.innerText="Eraser: Removes particles.";
      document.querySelectorAll(".element-btn").forEach(b=>b.classList.remove("active"));
    }
  },{passive:false});
}

function createToolbar(){
  Object.entries(categories).forEach(([category,particles])=>{
    const header=document.createElement("div");
    header.className="category-header";
    header.innerText=category;
    toolbar.appendChild(header);

    particles.forEach(type=>{
      if(type<=0) return;
      const btn=document.createElement("button");
      btn.className="element-btn";
      btn.style.backgroundColor=colors[type]||"#999";
      btn.innerText=names[type]||("ID "+type);
      btn.title=getParticleInfo(type);
      btn.onclick=()=>{
        document.querySelectorAll(".element-btn").forEach(b=>b.classList.remove("active"));
        btn.classList.add("active");
        tool=type;
        currentToolDisplay.innerText="Current: "+names[type];
        toolInfoDisplay.innerText=getParticleInfo(type);
      };
      toolbar.appendChild(btn);
    });
  });
}

function placeAtGrid(gx,gy,placeType){
  const r=brush;
  const r2=r*r;
  for(let dy=-r;dy<=r;dy++){
    const y=gy+dy;
    if(y<0||y>=rows) continue;
    for(let dx=-r;dx<=r;dx++){
      const x=gx+dx;
      if(x<0||x>=cols) continue;
      if(dx*dx+dy*dy>r2) continue;
      const i=idx(x,y);
      if(placeType===EMPTY){
        if(grid[i]!==WALL) clearCell(i);
      }else{
        if(placeType===WALL){
          setCell(i,WALL,ambientHeat);
        }else{
          if(grid[i]===WALL) continue;
          setCell(i,placeType,ambientHeat);
        }
      }
    }
  }
}

function pointerToGrid(e){
  const rect=canvas.getBoundingClientRect();
  const x=Math.floor((e.clientX-rect.left)/gridSize);
  const y=Math.floor((e.clientY-rect.top)/gridSize);
  return {x,y};
}

canvas.addEventListener("contextmenu",(e)=>e.preventDefault());
canvas.addEventListener("mousedown",(e)=>{
  drawing=true;
  const placeType=(e.button===2)?EMPTY:tool;
  suppressCloudRain=(placeType===CLOUD);
  const {x,y}=pointerToGrid(e);
  placeAtGrid(x,y,placeType);
});
canvas.addEventListener("mouseup",()=>{drawing=false;suppressCloudRain=false;});
canvas.addEventListener("mouseleave",()=>{drawing=false;suppressCloudRain=false;});
canvas.addEventListener("mousemove",(e)=>{
  if(!drawing) return;
  const placeType=(e.buttons&2)?EMPTY:tool;
  suppressCloudRain=(placeType===CLOUD);
  const {x,y}=pointerToGrid(e);
  placeAtGrid(x,y,placeType);
});

function createGlobalRain(){
  if(!globalRain) return;
  for(let x=0;x<cols;x+=3){
    if(Math.random()<0.13){
      const rx=x+((Math.random()*3)|0);
      if(rx<0||rx>=cols) continue;
      const i=idx(rx,0);
      if(grid[i]===EMPTY){
        setCell(i,WATER,ambientHeat);
        velY[i]=2.2+Math.random()*1.2;
        velX[i]=Math.random()*0.8-0.4;
        updated[i]=1;
      }
    }
  }
}

function diffuseTemperature(){
  const k=0.14;
  for(let y=0;y<rows;y++){
    const y0=y*cols;
    for(let x=0;x<cols;x++){
      const i=y0+x;
      let t=temp[i];
      let sum=t,ct=1;
      if(x>0){sum+=temp[i-1];ct++;}
      if(x<cols-1){sum+=temp[i+1];ct++;}
      if(y>0){sum+=temp[i-cols];ct++;}
      if(y<rows-1){sum+=temp[i+cols];ct++;}
      const avg=sum/ct;
      t=t+(avg-t)*k;
      t=t+(ambientHeat-t)*0.010;
      temp2[i]=t;
    }
  }
  temp.set(temp2);
}

function applyVelocity(i,x,y){
  const vx=velX[i],vy=velY[i];
  if(Math.abs(vx)<0.12 && Math.abs(vy)<0.12) return false;
  const nx=x+Math.max(-2,Math.min(2,Math.round(vx*0.45)));
  const ny=y+Math.max(-2,Math.min(2,Math.round(vy*0.45)));
  if(!inBounds(nx,ny)) return false;
  const j=idx(nx,ny);
  if(grid[j]===EMPTY){
    moveI(i,j);
    return true;
  }
  velX[i]*=-0.22;
  velY[i]*=-0.22;
  return false;
}

function fallThroughGas(i,x,y,dirY,maxDrop){
  let ny=y+dirY;
  if(ny<0||ny>=rows) return -1;
  let j=idx(x,ny);
  if(!passGas(grid[j])) return -1;
  let limitY=y+dirY*maxDrop;
  if(limitY<0) limitY=0;
  if(limitY>=rows) limitY=rows-1;
  while(ny!==limitY && passGas(grid[j])){
    ny+=dirY;
    if(ny<0||ny>=rows) return -1;
    j=idx(x,ny);
  }
  if(grid[j]===EMPTY) return j;
  return -1;
}

function movePowderStep(i,x,y,dirY){
  const y1=y+dirY;
  if(y1>=0&&y1<rows){
    const j=idx(x,y1);
    if(grid[j]===EMPTY){swapI(i,j);return true;}
    if(trySwapDensity(i,j)) return true;
    const dir=(Math.random()<0.5?-1:1);
    const nx=x+dir;
    if(nx>=0&&nx<cols){
      const jd=idx(nx,y1);
      if(grid[jd]===EMPTY){swapI(i,jd);return true;}
    }
    const nx2=x-dir;
    if(nx2>=0&&nx2<cols && Math.random()<0.35){
      const jd2=idx(nx2,y1);
      if(grid[jd2]===EMPTY){swapI(i,jd2);return true;}
    }
  }
  return false;
}

function moveLiquidStep(i,x,y,dirY,flow,spread){
  const gcol=fallThroughGas(i,x,y,dirY,22);
  if(gcol!==-1){moveI(i,gcol);return true;}

  const y1=y+dirY;
  if(y1>=0&&y1<rows){
    const j=idx(x,y1);
    if(grid[j]===EMPTY){swapI(i,j);return true;}
    if(trySwapDensity(i,j)) return true;
    const dirA=(Math.random()<0.5?-1:1);
    const nx=x+dirA;
    if(nx>=0&&nx<cols){
      const jd=idx(nx,y1);
      if(grid[jd]===EMPTY && Math.random()<flow){swapI(i,jd);return true;}
    }
    const nx2=x-dirA;
    if(nx2>=0&&nx2<cols){
      const jd2=idx(nx2,y1);
      if(grid[jd2]===EMPTY && Math.random()<flow*0.65){swapI(i,jd2);return true;}
    }
  }

  const dirStart=(Math.random()<0.5?-1:1);
  for(let s=1;s<=spread;s++){
    const nx=x+dirStart*s;
    if(nx<0||nx>=cols) break;
    const j=idx(nx,y);
    if(grid[j]!==EMPTY) break;
    if(Math.random()<flow){
      swapI(i,j);
      return true;
    }
  }
  for(let s=1;s<=spread;s++){
    const nx=x-dirStart*s;
    if(nx<0||nx>=cols) break;
    const j=idx(nx,y);
    if(grid[j]!==EMPTY) break;
    if(Math.random()<flow*0.9){
      swapI(i,j);
      return true;
    }
  }
  return false;
}

function moveGasStep(i,x,y,dirY){
  const y1=y+dirY;
  if(y1>=0&&y1<rows){
    const j=idx(x,y1);
    if(grid[j]===EMPTY && Math.random()<0.92){swapI(i,j);return true;}
  }
  const wx=wind+(Math.random()*0.6-0.3);
  const dir=(wx>=0?1:-1);
  const nx=x+dir;
  if(nx>=0&&nx<cols){
    const j=idx(nx,y);
    if(grid[j]===EMPTY && Math.random()<0.42){swapI(i,j);return true;}
  }
  const nx2=x-dir;
  if(nx2>=0&&nx2<cols){
    const j=idx(nx2,y);
    if(grid[j]===EMPTY && Math.random()<0.22){swapI(i,j);return true;}
  }
  return false;
}

function moveCloudStep(i,x,y){
  const y1=y-1;
  if(y1>=0){
    const j=idx(x,y1);
    if(grid[j]===EMPTY && Math.random()<0.62){swapI(i,j);return true;}
  }
  const wx=wind*0.65+(Math.random()*0.8-0.4);
  const dir=(wx>=0?1:-1);
  const nx=x+dir;
  if(nx>=0&&nx<cols){
    const j=idx(nx,y);
    if(grid[j]===EMPTY && Math.random()<0.50){swapI(i,j);return true;}
  }
  const nx2=x-dir;
  if(nx2>=0&&nx2<cols){
    const j=idx(nx2,y);
    if(grid[j]===EMPTY && Math.random()<0.25){swapI(i,j);return true;}
  }
  return false;
}

const nbuf=new Int32Array(8);

function updateCell(i,x,y){
  const c=grid[i];
  if(c===EMPTY||updated[i]) return;

  particleCount++;

  if(tick%60===0) wind=Math.max(-0.9,Math.min(0.9,wind+(Math.random()*0.6-0.3)));

  if(isGas(c)){
    velY[i]+=(-0.10);
    velX[i]*=0.965;
    velY[i]*=0.965;
    velX[i]+=wind*0.03;
  }else{
    velY[i]+=gravity*0.14;
    velX[i]*=0.92;
    velY[i]*=0.92;
  }

  const t=temp[i];

  if(c===WATER && t<0){grid[i]=ICE;updated[i]=1;cloudMoisture[i]=0;return;}
  if(c===ICE && t>0){grid[i]=WATER;updated[i]=1;cloudMoisture[i]=0;return;}
  if(c===SNOW && t>1 && Math.random()<0.06){grid[i]=WATER;updated[i]=1;cloudMoisture[i]=0;return;}

  if(c===WATER && t>100){
    grid[i]=SMOKE;
    temp[i]=Math.max(temp[i],120);
    velY[i]=-1.35;
    velX[i]*=0.2;
    cloudMoisture[i]=0;
    updated[i]=1;
    return;
  }

  if(c===STONE && t>1200 && Math.random()<0.03){grid[i]=LAVA;temp[i]=Math.max(t,900);updated[i]=1;return;}
  if(c===METAL && t>1400 && Math.random()<0.02){grid[i]=LAVA;temp[i]=Math.max(t,1000);updated[i]=1;return;}
  if(c===SAND && t>1550 && Math.random()<0.02){grid[i]=GLASS;updated[i]=1;return;}
  if(c===GLASS && (t>1800||t<-40) && Math.random()<0.003){grid[i]=SAND;updated[i]=1;return;}

  const ncount=neighbors8(x,y,nbuf);

  if(c===FIRE){
    temp[i]=Math.max(t,820);
    for(let k=0;k<ncount;k++){
      const j=nbuf[k];
      const tj=grid[j];
      if(tj===WATER && Math.random()<0.24){
        grid[j]=SMOKE;
        temp[j]=Math.max(temp[j],120);
        velY[j]=-1.55;
        velX[j]=Math.random()*0.6-0.3;
        grid[i]=SMOKE;
        cloudMoisture[i]=0;
        cloudMoisture[j]=0;
        updated[i]=1;
        updated[j]=1;
        return;
      }
      if(tj===ICE||tj===SNOW){
        grid[j]=WATER;
        temp[j]=Math.max(temp[j],10);
        cloudMoisture[j]=0;
        updated[j]=1;
      }
      if(tj===ACID && Math.random()<0.10){
        grid[j]=SMOKE;
        temp[j]=Math.max(temp[j],200);
        cloudMoisture[j]=0;
        updated[j]=1;
      }
      if(tj===OIL||tj===WOOD||tj===PLANT||tj===SEED||tj===HONEY||tj===GUNPOWDER||tj===FUNGUS){
        grid[j]=FIRE;
        temp[j]=Math.max(temp[j],820);
        cloudMoisture[j]=0;
        updated[j]=1;
      }
      temp[j]=Math.max(temp[j],temp[i]-55);
    }
    if(Math.random()<0.022){
      grid[i]=Math.random()<0.35?ASH:SMOKE;
      cloudMoisture[i]=0;
      updated[i]=1;
    }else{
      updated[i]=1;
    }
    return;
  }

  if(c===LAVA||c===MAGMA){
    temp[i]=Math.max(t,c===MAGMA?1200:950);
    for(let k=0;k<ncount;k++){
      const j=nbuf[k];
      const tj=grid[j];
      temp[j]=Math.max(temp[j],temp[i]-220);
      if(tj===WOOD||tj===PLANT||tj===SEED||tj===FUNGUS||tj===HONEY||tj===OIL||tj===GUNPOWDER){
        grid[j]=FIRE;
        temp[j]=Math.max(temp[j],820);
        cloudMoisture[j]=0;
        updated[j]=1;
      }
      if(tj===WATER){
        if(Math.random()<0.55){
          grid[j]=SMOKE;
          temp[j]=Math.max(temp[j],140);
          velY[j]=-1.75;
          velX[j]=Math.random()*0.6-0.3;
          cloudMoisture[j]=0;
          updated[j]=1;
        }
        if(Math.random()<0.26){
          grid[i]=STONE;
          temp[i]=Math.min(temp[i],300);
          cloudMoisture[i]=0;
          updated[i]=1;
        }else if(Math.random()<0.26){
          grid[j]=STONE;
          temp[j]=Math.min(temp[j],300);
          cloudMoisture[j]=0;
          updated[j]=1;
        }
      }
      if(c===MAGMA){
        if(tj===STONE && Math.random()<0.07){grid[j]=LAVA;temp[j]=Math.max(temp[j],950);updated[j]=1;}
        if(tj===METAL && Math.random()<0.05){grid[j]=LAVA;temp[j]=Math.max(temp[j],1000);updated[j]=1;}
        if(tj===GLASS && Math.random()<0.03){grid[j]=LAVA;temp[j]=Math.max(temp[j],1000);updated[j]=1;}
      }
    }
    moveLiquidStep(i,x,y,gravity>=0?1:-1,0.55,3);
    if(temp[i]<650 && Math.random()<0.024){
      grid[i]=STONE;
      temp[i]=Math.min(temp[i],350);
      cloudMoisture[i]=0;
      updated[i]=1;
    }
    return;
  }

  if(c===LIQUID_N){
    temp[i]=Math.min(t,-160);
    for(let k=0;k<ncount;k++){
      const j=nbuf[k];
      const tj=grid[j];
      temp[j]=Math.min(temp[j],-40);
      if(tj===WATER){grid[j]=ICE;temp[j]=Math.min(temp[j],-10);cloudMoisture[j]=0;updated[j]=1;}
      if(tj===FIRE){grid[j]=SMOKE;temp[j]=Math.min(temp[j],60);cloudMoisture[j]=0;updated[j]=1;}
      if(tj===LAVA||tj===MAGMA){grid[j]=STONE;temp[j]=Math.min(temp[j],400);cloudMoisture[j]=0;updated[j]=1;}
      if(tj===SMOKE && Math.random()<0.22){clearCell(j);updated[j]=1;}
      if(tj===CLOUD && Math.random()<0.25){cloudMoisture[j]=Math.max(0,cloudMoisture[j]-25);updated[j]=1;}
    }
    moveLiquidStep(i,x,y,gravity>=0?1:-1,0.52,3);
    if(Math.random()<0.012){clearCell(i);updated[i]=1;}
    return;
  }

  if(c===ELEC){
    for(let k=0;k<ncount;k++){
      const j=nbuf[k];
      const tj=grid[j];
      if(tj===WATER||tj===METAL||tj===CRYSTAL||tj===WIRE||tj===BATTERY){
        if(tj===WATER){
          if(Math.random()<0.78){grid[j]=ELEC;updated[j]=1;}
        }else{
          if(Math.random()<0.55){
            for(let m=0;m<ncount;m++){
              const a=nbuf[m];
              if(grid[a]===EMPTY && Math.random()<0.18){grid[a]=ELEC;updated[a]=1;}
            }
          }
        }
      }
      if(tj===OIL||tj===PLANT||tj===WOOD||tj===GUNPOWDER||tj===HONEY){
        grid[j]=FIRE;
        temp[j]=Math.max(temp[j],820);
        cloudMoisture[j]=0;
        updated[j]=1;
      }
    }
    if(Math.random()<0.16){clearCell(i);updated[i]=1;}else updated[i]=1;
    return;
  }

  if(c===BATTERY){
    let charge=batteryCharge[i];
    for(let k=0;k<ncount;k++){
      const j=nbuf[k];
      if(grid[j]===ELEC){
        charge=Math.min(charge+28,220);
        clearCell(j);
        updated[j]=1;
      }
    }
    if(charge>0){
      for(let k=0;k<ncount;k++){
        const j=nbuf[k];
        if(grid[j]===BATTERY && batteryCharge[j]<charge){
          batteryCharge[j]=charge;
          updated[j]=1;
        }
      }
    }
    if(charge>=200){
      let discharged=false;
      for(let k=0;k<ncount;k++){
        const j=nbuf[k];
        const tj=grid[j];
        if((tj===EMPTY||tj===WIRE||tj===METAL||tj===WATER||tj===CRYSTAL) && Math.random()<0.40){
          grid[j]=ELEC;
          updated[j]=1;
          discharged=true;
        }
      }
      if(discharged||Math.random()<0.15) charge=0;
    }else{
      if(charge>0 && Math.random()<0.012) charge=Math.max(0,charge-1);
    }
    batteryCharge[i]=charge;
    updated[i]=1;
    return;
  }

  if(c===WIRE){
    for(let k=0;k<ncount;k++){
      const j=nbuf[k];
      if(grid[j]===ELEC && Math.random()<0.70){
        for(let m=0;m<ncount;m++){
          const a=nbuf[m];
          if(grid[a]===WIRE && Math.random()<0.75){
            for(let q=0;q<8;q++){
              const b=nbuf[q];
              if(grid[b]===EMPTY && Math.random()<0.22){grid[b]=ELEC;updated[b]=1;}
            }
          }
        }
      }
    }
    updated[i]=1;
    return;
  }

  if(c===ACID){
    moveLiquidStep(i,x,y,gravity>=0?1:-1,0.56,4);
    for(let k=0;k<ncount;k++){
      const j=nbuf[k];
      const tj=grid[j];
      if(tj===WALL||tj===DIAMOND||tj===ACID) continue;
      if(tj===WATER && Math.random()<0.10){
        grid[i]=WATER;
        temp[i]=Math.min(temp[i],ambientHeat);
        cloudMoisture[i]=0;
        clearCell(j);
        updated[i]=1;
        updated[j]=1;
        return;
      }
      if(tj!==EMPTY && !passGas(tj) && Math.random()<0.075){
        if(tj===CRYSTAL||tj===GLASS){
          clearCell(j);
          updated[j]=1;
        }else if(tj===METAL){
          grid[j]=SMOKE;
          cloudMoisture[j]=0;
          temp[j]=Math.max(temp[j],190);
          updated[j]=1;
        }else{
          grid[j]=Math.random()<0.28?SMOKE:EMPTY;
          cloudMoisture[j]=0;
          updated[j]=1;
        }
      }
    }
    if(Math.random()<0.0065){clearCell(i);updated[i]=1;}
    return;
  }

  if(c===OIL){
    moveLiquidStep(i,x,y,gravity>=0?1:-1,0.64,5);
    const yb=y+(gravity>=0?1:-1);
    if(yb>=0&&yb<rows){
      const j=idx(x,yb);
      if(grid[j]===WATER && Math.random()<0.36){swapI(i,j);return;}
    }
    for(let k=0;k<ncount;k++){
      const j=nbuf[k];
      if(grid[j]===FIRE && Math.random()<0.28){
        grid[i]=FIRE;
        temp[i]=Math.max(temp[i],820);
        cloudMoisture[i]=0;
        updated[i]=1;
        return;
      }
    }
    return;
  }

  if(c===WATER){
    moveLiquidStep(i,x,y,gravity>=0?1:-1,0.72,6);
    for(let k=0;k<ncount;k++){
      const j=nbuf[k];
      const tj=grid[j];
      if(tj===SALT && Math.random()<0.28){
        clearCell(j);
        updated[j]=1;
        if(Math.random()<0.08){grid[i]=SALT;updated[i]=1;return;}
      }
      if(tj===ASH && Math.random()<0.12){clearCell(j);updated[j]=1;}
      if(tj===FIRE && Math.random()<0.22){
        grid[j]=SMOKE;
        cloudMoisture[j]=0;
        updated[j]=1;
        grid[i]=SMOKE;
        temp[i]=Math.max(temp[i],120);
        velY[i]=-1.45;
        velX[i]=Math.random()*0.5-0.25;
        cloudMoisture[i]=0;
        updated[i]=1;
        return;
      }
    }
    return;
  }

  if(c===HONEY){
    moveLiquidStep(i,x,y,gravity>=0?1:-1,0.25,3);
    for(let k=0;k<ncount;k++){
      const j=nbuf[k];
      if(grid[j]===FIRE && Math.random()<0.14){
        grid[i]=FIRE;
        temp[i]=Math.max(temp[i],820);
        cloudMoisture[i]=0;
        updated[i]=1;
        return;
      }
    }
    return;
  }

  if(c===MUD){
    moveLiquidStep(i,x,y,gravity>=0?1:-1,0.38,4);
    for(let k=0;k<ncount;k++){
      const j=nbuf[k];
      const tj=grid[j];
      if(tj===WATER && Math.random()<0.14 && waterContent[i]<110){
        clearCell(j);
        updated[j]=1;
        waterContent[i]=Math.min(110,waterContent[i]+26);
      }
    }
    if(Math.random()<0.010) waterContent[i]=Math.max(0,waterContent[i]-1);
    return;
  }

  if(c===SAND){
    for(let k=0;k<ncount;k++){
      const j=nbuf[k];
      if(grid[j]===WATER && Math.random()<0.16){
        grid[i]=MUD;
        waterContent[i]=55;
        clearCell(j);
        updated[i]=1;
        updated[j]=1;
        return;
      }
    }
    movePowderStep(i,x,y,gravity>=0?1:-1);
    return;
  }

  if(c===SNOW){
    movePowderStep(i,x,y,gravity>=0?1:-1);
    return;
  }

  if(c===SALT){
    movePowderStep(i,x,y,gravity>=0?1:-1);
    for(let k=0;k<ncount;k++){
      const j=nbuf[k];
      if(grid[j]===WATER && Math.random()<0.10){
        clearCell(i);
        updated[i]=1;
        return;
      }
    }
    return;
  }

  if(c===GUNPOWDER){
    movePowderStep(i,x,y,gravity>=0?1:-1);
    for(let k=0;k<ncount;k++){
      const j=nbuf[k];
      const tj=grid[j];
      if(tj===FIRE||tj===ELEC){
        explode(x,y,6,2);
        clearCell(i);
        updated[i]=1;
        return;
      }
    }
    return;
  }

  if(c===ASH){
    movePowderStep(i,x,y,gravity>=0?1:-1);
    for(let k=0;k<ncount;k++){
      const j=nbuf[k];
      if(grid[j]===WATER && Math.random()<0.09){
        clearCell(i);
        updated[i]=1;
        return;
      }
    }
    return;
  }

  if(c===SMOKE){
    moveGasStep(i,x,y,-1);
    if(Math.random()<0.017){clearCell(i);updated[i]=1;}
    return;
  }

  if(c===CLOUD){
    moveCloudStep(i,x,y);
    let m=cloudMoisture[i];

    if(m<220){
      for(let k=0;k<ncount;k++){
        const j=nbuf[k];
        const tj=grid[j];
        if(tj===WATER){
          if(t>18 && Math.random()<0.065) m=Math.min(220,m+2);
        }
        if(tj===LIQUID_N && Math.random()<0.08){
          m=Math.max(0,m-10);
        }
      }
    }

    if(!suppressCloudRain && m>18 && Math.random()<Math.min(0.60,0.05+(m/220)*0.40)){
      const by=y+1;
      if(by<rows){
        const drops=1+((Math.random()*3)|0);
        for(let d=0;d<drops;d++){
          const rx=x+(((Math.random()*3)|0)-1);
          if(rx<0||rx>=cols) continue;
          const j=idx(rx,by);
          if(grid[j]===EMPTY){
            setCell(j,WATER,ambientHeat);
            velY[j]=2.0+Math.random()*1.2;
            velX[j]=Math.random()*0.4-0.2;
            updated[j]=1;
            m=Math.max(0,m-(10+((Math.random()*8)|0)));
          }
        }
      }
    }else if(m>0 && Math.random()<0.004){
      m=Math.max(0,m-1);
    }

    cloudMoisture[i]=m;
    updated[i]=1;
    return;
  }

  if(c===PLANT){
    let touchingWater=false;
    for(let k=0;k<ncount;k++){if(grid[nbuf[k]]===WATER){touchingWater=true;break;}}
    if(touchingWater && Math.random()<0.0022){
      for(let k=0;k<ncount;k++){
        const j=nbuf[k];
        if(grid[j]===EMPTY && Math.random()<0.05){
          grid[j]=PLANT;
          temp[j]=Math.min(temp[j],ambientHeat);
          updated[j]=1;
        }
      }
    }
    updated[i]=1;
    return;
  }

  if(c===SEED){
    const yb=y+(gravity>=0?1:-1);
    const below=(yb>=0&&yb<rows)?grid[idx(x,yb)]:WALL;
    const onSoil=(below===MUD||below===SAND||below===PLANT);
    let nearWater=false;
    for(let k=0;k<ncount;k++){if(grid[nbuf[k]]===WATER){nearWater=true;break;}}
    if(onSoil && nearWater && Math.random()<0.004){
      grid[i]=WOOD;
      temp[i]=Math.min(temp[i],ambientHeat);
      const ya=y-1;
      if(ya>=0){
        const j=idx(x,ya);
        if(grid[j]===EMPTY && Math.random()<0.75){
          grid[j]=PLANT;
          temp[j]=Math.min(temp[j],ambientHeat);
          updated[j]=1;
        }
      }
      updated[i]=1;
      return;
    }
    movePowderStep(i,x,y,gravity>=0?1:-1);
    return;
  }

  if(c===VIRUS){
    for(let k=0;k<ncount;k++){
      const j=nbuf[k];
      const tj=grid[j];
      if((tj===PLANT||tj===WOOD||tj===SEED||tj===LIFE||tj===FUNGUS) && Math.random()<0.065){
        grid[j]=VIRUS;
        updated[j]=1;
      }
      if(tj===ACID && Math.random()<0.22){clearCell(i);updated[i]=1;return;}
      if(tj===FIRE && Math.random()<0.22){grid[i]=SMOKE;updated[i]=1;return;}
    }
    if(Math.random()<0.0013){clearCell(i);updated[i]=1;}
    return;
  }

  if(c===CRYSTAL){
    for(let k=0;k<ncount;k++){
      const j=nbuf[k];
      const tj=grid[j];
      if(tj===WATER && Math.random()<0.0018){
        grid[j]=CRYSTAL;
        temp[j]=Math.min(temp[j],ambientHeat);
        updated[j]=1;
      }
      if(tj===ACID && Math.random()<0.045){clearCell(i);updated[i]=1;return;}
    }
    updated[i]=1;
    return;
  }

  if(c===LIFE){
    if(Math.random()<0.003){
      for(let k=0;k<ncount;k++){
        const j=nbuf[k];
        if(grid[j]===EMPTY && Math.random()<0.16){
          grid[j]=Math.random()<0.55?PLANT:SEED;
          temp[j]=Math.min(temp[j],ambientHeat);
          updated[j]=1;
        }
      }
    }
    updated[i]=1;
    return;
  }

  if(c===FUNGUS){
    if(Math.random()<0.004){
      for(let k=0;k<ncount;k++){
        const j=nbuf[k];
        const tj=grid[j];
        if((tj===EMPTY||tj===PLANT||tj===WOOD) && Math.random()<0.12){
          grid[j]=FUNGUS;
          temp[j]=Math.min(temp[j],ambientHeat);
          updated[j]=1;
        }
        const jy=j-cols;
        if(jy>=0 && tj!==EMPTY && tj!==WALL && grid[jy]===EMPTY && Math.random()<0.03){
          grid[jy]=FUNGUS;
          temp[jy]=Math.min(temp[jy],ambientHeat);
          updated[jy]=1;
        }
      }
    }
    updated[i]=1;
    return;
  }

  if(c===CORAL){
    let touchingWater=false;
    for(let k=0;k<ncount;k++){if(grid[nbuf[k]]===WATER){touchingWater=true;break;}}
    if(touchingWater && Math.random()<0.006){
      for(let k=0;k<ncount;k++){
        const j=nbuf[k];
        if(grid[j]===EMPTY && Math.random()<0.12){
          grid[j]=CORAL;
          temp[j]=Math.min(temp[j],ambientHeat);
          updated[j]=1;
        }
      }
    }
    updated[i]=1;
    return;
  }

  if(c===RADIATION){
    if(Math.random()<0.024){
      for(let k=0;k<ncount;k++){
        const j=nbuf[k];
        const tj=grid[j];
        if(tj!==EMPTY && tj!==WALL && tj!==DIAMOND && tj!==RADIATION && Math.random()<0.065){
          const possibilities=[SAND,WATER,FIRE,STONE,METAL,CRYSTAL,PLANT,ACID,SMOKE,VIRUS,ICE,SNOW,ASH,OIL];
          const nt=possibilities[(Math.random()*possibilities.length)|0];
          grid[j]=nt;
          updated[j]=1;
        }
      }
    }
    if(Math.random()<0.0022){clearCell(i);updated[i]=1;}
    return;
  }

  if(c===CLONE){
    if(Math.random()<0.14){
      const picks=[];
      for(let k=0;k<ncount;k++){
        const j=nbuf[k];
        const tj=grid[j];
        if(tj!==EMPTY && tj!==WALL && tj!==CLONE) picks.push(j);
      }
      if(picks.length){
        const j=picks[(Math.random()*picks.length)|0];
        const tj=grid[j];
        grid[i]=tj;
        temp[i]=temp[j];
        velX[i]=velX[j]*0.5;
        velY[i]=velY[j]*0.5;
        batteryCharge[i]=batteryCharge[j];
        waterContent[i]=waterContent[j];
        cloudMoisture[i]=(tj===CLOUD)?cloudMoisture[j]:0;
        updated[i]=1;
      }
    }
    return;
  }

  if(c===ICE){
    if(Math.random()<0.0012 && t<-20){
      for(let k=0;k<ncount;k++){
        const j=nbuf[k];
        if(grid[j]===WATER && Math.random()<0.07){
          grid[j]=ICE;
          temp[j]=Math.min(temp[j],-5);
          cloudMoisture[j]=0;
          updated[j]=1;
        }
      }
    }
    updated[i]=1;
    return;
  }

  if(c===METAL){
    for(let k=0;k<ncount;k++){
      const j=nbuf[k];
      if(grid[j]===ACID && Math.random()<0.012){
        grid[i]=SMOKE;
        cloudMoisture[i]=0;
        updated[i]=1;
        return;
      }
    }
    updated[i]=1;
    return;
  }

  if(c===CONCRETE){
    for(let k=0;k<ncount;k++){
      const j=nbuf[k];
      if(grid[j]===ACID && Math.random()<0.010){
        grid[i]=SAND;
        updated[i]=1;
        return;
      }
    }
    updated[i]=1;
    return;
  }

  if(!isGas(c)) applyVelocity(i,x,y);
  updated[i]=1;
}

function update(){
  if(paused) return;

  tick++;
  particleCount=0;
  updated.fill(0);

  if((tick&1)===0) diffuseTemperature();
  createGlobalRain();

  const dirY=gravity>=0?1:-1;
  const startY=dirY===1?rows-1:0;
  const endY=dirY===1?-1:rows;
  const stepY=dirY===1?-1:1;

  for(let y=startY;y!==endY;y+=stepY){
    const base=y*cols;
    const xStart=(Math.random()*cols)|0;
    for(let xo=0;xo<cols;xo++){
      const x=(xStart+xo)%cols;
      const i=base+x;
      updateCell(i,x,y);
    }
  }

  if(!drawing) suppressCloudRain=false;
}

function draw(){
  const img=ctx.getImageData(0,0,canvas.width,canvas.height);
  const data=img.data;

  for(let gy=0;gy<rows;gy++){
    for(let gx=0;gx<cols;gx++){
      const i=idx(gx,gy);
      const c=grid[i];
      const px=gx*gridSize;
      const py=gy*gridSize;

      let r=0,g=0,b=0,a=255;

      if(c!==EMPTY){
        let col=colors[c]||"#999";
        r=parseInt(col.slice(1,3),16);
        g=parseInt(col.slice(3,5),16);
        b=parseInt(col.slice(5,7),16);

        const tt=temp[i];
        if(tt>100){
          const heat=Math.min((tt-100)/700,1);
          r=255;
          g=Math.max(0,Math.min(255,Math.floor(255*(1-heat*0.55))));
          b=Math.max(0,Math.min(255,Math.floor(255*(1-heat))));
        }else if(tt<0){
          const cold=Math.min(Math.abs(tt)/120,1);
          r=Math.max(0,Math.min(255,Math.floor(255*(1-cold*0.4))));
          g=Math.max(0,Math.min(255,Math.floor(255*(1-cold*0.4))));
          b=255;
        }

        if(c===BATTERY){
          const ch=batteryCharge[i]/220;
          r=Math.floor(255*(1-ch));
          g=Math.floor(255*ch);
          b=0;
        }

        if(c===CLOUD){
          const m=cloudMoisture[i]/220;
          a=Math.floor(255*(0.46+0.42*m));
        }else if(c===FIRE||c===ELEC){
          a=Math.floor(255*(0.70+Math.random()*0.30));
        }else{
          a=255;
        }
      }

      for(let oy=0;oy<gridSize;oy++){
        const rowOff=((py+oy)*canvas.width+px)*4;
        for(let ox=0;ox<gridSize;ox++){
          const p=rowOff+ox*4;
          data[p]=r;
          data[p+1]=g;
          data[p+2]=b;
          data[p+3]=a;
        }
      }
    }
  }

  ctx.putImageData(img,0,0);
}

let lastTime=performance.now();
let frames=0;

function loop(now){
  requestAnimationFrame(loop);
  if(!paused){
    for(let i=0;i<speed;i++) update();
  }
  draw();

  frames++;
  if(now-lastTime>1000){
    fpsDisplay.innerText=`FPS: ${frames}`;
    particleDisplay.innerText=`Particles: ${particleCount.toLocaleString()}`;
    frames=0;
    lastTime=now;
  }
}

initializeUI();
createToolbar();
currentToolDisplay.innerText="Current: "+names[tool];
toolInfoDisplay.innerText=getParticleInfo(tool);

for(let i=0;i<size;i++) temp[i]=25;

loop(performance.now());
</script>
</body>
</html>
